# Definitions and functions related to Lie subalgebras of the orthogonal Lie algebra so(n)

def lie_bracket(X, Y):
    return X * Y - Y * X

def biinv_metric(X, Y):
    return - (X * Y).trace()

def is_li(gens):
    """
    This function checks if a given set 'gens' of matrices is linearly independent.
    """
    n = len(gens)
    M = matrix([gens[i].list() for i in range(n)])
    if M.rank() == n:
        return True
    else:
        return False

def is_lie_algebra(basis):
    """
    This function checks if a given set 'basis' of matrices is a basis of a matrix Lie subalgebra.
    """
    if is_li(basis) == False:
        print("Not a linear independent set.")
    else:
        n = len(basis)
        M = matrix([basis[i].list() for i in range(n)])
        for i in range(n):
            for j in range(i+1, n):
                if matrix(M.rows() + [vector(lie_bracket(basis[i], basis[j]).list())]).rank() > n:
                    return False
        return True

def is_lie_subalgebra(h_basis, g_basis):
    """
    This function checks if 'h_basis' is the basis of a Lie algebra which is a Lie subalgebra of the Lie algebra generated by 'g_basis'.
    """
    if is_lie_algebra(h_basis):
        for X in h_basis:
            if is_li(g_basis + [X]):
                return False
        return True

def gram_schmidt(basis, metric):
    """
    This function applies the Gram-Schmidt process to 'basis' with respect to the inner product given by 'metric'.
    """
    on_basis = []
    for i, X in enumerate(basis):
        Y = X
        for j in range(i):
            Y -= metric(X, on_basis[j]) * on_basis[j]
        on_basis.append(1/sqrt(metric(Y, Y)) * Y)
    return on_basis
